# Pixel Processing - Fork Phase

In this part, Iâ€™ll be dealing with the first half of pixel processing: dispatch and actual pixel shading. In fact, this is really what most graphics programmer think about when talking about pixel processing; the alpha blend and late Z stages weâ€™ll encounter in the next part seem like little more than an afterthought. In hardware, the story is a bit more complicated, as weâ€™ll see â€“ thereâ€™s a reason Iâ€™m splitting pixel processing into two parts. But Iâ€™m getting ahead of myself. At the point where weâ€™re entering this stage, the coordinates of pixels (or, actually, quads) to shade, plus associated coverage masks, arrive from the rasterizer/early-Z unit â€“ with triangle in the exact same order as submitted by the application, as I pointed out last time. What we need to do here is to take that linear, sequential stream of work and farm it out to hundreds of shader units, then once the results are back, we need to merge it back into one linear stream of memory updates.

Thatâ€™s a textbook example of fork/join-parallelism. This part deals with the fork phase, where we go wide; the next part will explain the join phase, where we merge the hundreds of streams back into one. But first, I have a few more words to say about rasterization, because what I just told you about there being just one stream of quads coming in isnâ€™t quite true.

## Going Wide During Rasterization

To my defense, what I told you _used_ to be true for quite a long time, but itâ€™s a serial part of the pipeline, and once you throw in excess of 300 shader units at a problem, serial parts of the pipeline have the tendency to become bottlenecks. So GPU architects started using multiple rasterizers; as of 2010, [NVidia employs four rasterizers](http://www.highperformancegraphics.org/previous/www_2010/media/Hot3D/HPG2010_Hot3D_NVIDIA.pdf) and [AMD uses two](http://www.highperformancegraphics.org/previous/www_2010/media/Hot3D/HPG2010_Hot3D_AMD.pdf). As a side note, the NV presentation also has a few notes on the requirement to keep stuff in API order. In particular, you really do need to sort primitives back into order prior to rasterization/early-Z, like I mentioned last time; doing it just before alpha blend (as you might be inclined to do) doesnâ€™t work.

The work distribution between rasterizers is based on the tiles weâ€™ve already seen for early-Z and coarse rasterization. The frame buffer is divided into tile-sized regions, and each region is assigned to one of the rasterizers. After setup, the bounding box of the triangle is consulted to find out which triangles to hand over to which rasterizers; large triangles will always be sent to all rasterizers, but smaller ones can hit as little as one tile and will only be sent to the rasterizer that owns it.

The beauty of this scheme is that it only requires changes to the work distribution and the coarse rasterizers (which traverse tiles); everything that only sees individual tiles or quads (that is, the pipeline from hierarchical Z down) doesnâ€™t need to be modified. The problem is that youâ€™re now dividing jobs based on screen locations; this can lead to a severe load imbalance between the rasterizers (think a few hundred tiny triangles all inside a single tile) that you canâ€™t really do anything about. But the nice thing is that everything that adds ordering constraints to the pipeline (Z-test/write order, blend order) comes attached to specific frame-buffer locations, so screen-space subdivision works without breaking API order â€“ if this wasnâ€™t the case, tiled renderers wouldnâ€™t work.

## You Need To Go Wider!

Okay, so we donâ€™t get just one linear stream of quad coordinates plus coverage masks in, but between two and four. We still need to farm them out to hundreds of shader units. Itâ€™s time for another dispatch unit! Which first means another buffer. But how big are the batches we send off to the shaders? Here I go with NVidia figures again, simply because they mention this number in [public white papers](http://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf); AMD probably also states that information somewhere, but Iâ€™m not familiar with their terminology for it so I couldnâ€™t do a direct search for it. Anyway, for NVidia, the unit of dispatch to shader units is 32 threads, which they call a "Warp". Each quad has 4 pixels (each of which in turn can be handled as one thread), so for each shading batch we issue, we need to grab 8 incoming quads from the rasterizer before we can send off a batch to the shader units (we might send less in case thereâ€™s a shader switch or pipeline flush).

Also, this is a good point to explain why weâ€™re dealing with quads of 2Ã—2 pixels and not individual pixels. The big reason is derivatives. Texture samplers depend on screen-space derivatives of texture coordinates to do their mip-map selection and filtering (as we saw back in [part 4](https://fgiesen.wordpress.com/2011/07/04/a-trip-through-the-graphics-pipeline-2011-part-4/)); and, as of shader model 3.0 and later, the same machinery is directly available to pixel shaders in the form of derivative instructions. In a quad, each pixel has both a horizontal and vertical neighbor within the same quad; this can be used to estimate the derivatives of parameters in the x and y directions using [finite differencing](http://en.wikipedia.org/wiki/Finite_difference) (it boils down to a few subtractions). This gives you a very cheap way to get derivatives at the cost of always having to shade groups of 2Ã—2 pixels at once. This is no problem in the interior of large triangles, but means that between 25-75% of the shading work for quads generated for triangle edges is wasted. Thatâ€™s because all pixels in a quad, even the masked ones, get shaded. This is necessary to produce correct derivatives for the pixels in the quad that are visible. The invisible but still-shaded pixels are called "helper pixels". Hereâ€™s an illustration for a small triangle:

[![Quad coverage of a small triangle](https://fgiesen.files.wordpress.com/2011/07/quad_coverage.png?w=497 "Quad coverage of a small triangle")](https://fgiesen.files.wordpress.com/2011/07/quad_coverage.png)

The triangle intersects 4 quads, but only generates visible pixels in 3 of them. Furthermore, in each of the 3 quads, only one pixel is actually covered (the sampling points for each pixel region are depicted as black circles) â€“ the pixels that are filled are depicted in red. The remaining pixels in each partially-covered quad are helper pixels, and drawn with a lighter color. This illustration should make it clear that for small triangles, a large fraction of the total number of pixels shaded are helper pixels, which has attracted some [research attention](http://graphics.stanford.edu/papers/fragmerging/shade_sig10.pdf) on how to merge quads of adjacent triangles. However, while clever, such optimizations are not permissible by current API rules, and current hardware doesnâ€™t do them. Of course, if the HW vendors at some point decide that wasted shading work on quads is a significant enough problem to force the issue, this will likely change.

## Attribute Interpolation

Another unique feature of pixel shaders is attribute interpolation â€“ all other shader types, both the ones weâ€™ve seen so far (VS) and the ones weâ€™re still to talk about (GS, HS, DS, CS) get inputs directly from a preceding shader stage or memory, but pixel shaders have an additional interpolation step in front of them. Iâ€™ve already talked a bit about this in the [previous part](https://fgiesen.wordpress.com/2011/07/08/a-trip-through-the-graphics-pipeline-2011-part-7/) when discussing Z, which was the first interpolated attribute we saw.

Other interpolated attributes work much the same way; a plane equation for them is computed during triangle setup (GPUs may choose to defer this computation somewhat, e.g. until itâ€™s known that at least one tile of the triangle passed the hierarchical Z-test, but that shall not concern us here), and then during pixel shading, thereâ€™s a separate unit that performs attribute interpolation using the pixel positions of the quads and the plane equations we just computed.

**Update**: Marco Salvi points out (in the comments below) that while there used to be dedicated interpolators, by now the trend is towards just having them return the barycentric coordinates to plug into the plane equations. The actual evaluation (two multiply-adds per attribute) can be done in the shader unit.

All of this shouldnâ€™t be surprising, but thereâ€™s a few extra interpolation types to discuss. First, thereâ€™s "constant" interpolators, which are (surprise!) constant across the primitive and take the value for each vertex attribute from the "leading vertex" (which vertex that is is determined during primitive setup). Hardware may either have a fast-path for this or just set up a corresponding plane equation; either way works fine.

Then thereâ€™s no-perspective interpolation. This will usually set up the plane equations differently; the plane equations for perspective-correct interpolation are set up either for X, Y-based interpolation by dividing the attribute values at each vertex by the corresponding w, or for barycentric interpolation by building the triangle edge vectors. Non-perspective interpolated attributes, however, are cheapest to evaluate when their plane equation is set up for X, Y-based interpolation _without_ dividing the values at each vertex by the corresponding w.

## "centroid" Interpolation is Tricky

Next, we have "centroid" interpolation. This is a flag, not a separate mode; it can be combined both with the perspective and no-perspective modes (but not with constant interpolation, because it would be pointless). Itâ€™s also terribly named and a no-op unless multisampling is enabled. With multisampling ob, itâ€™s a somewhat hacky solution to a real problem. The issue is that with multisampling, weâ€™re evaluating triangle _coverage_ at multiple sample points in the rasterizer, but weâ€™re only doing the actual _shading_ once per pixel. Attributes such as texture coordinates will be interpolated at the pixel center position, as if the whole pixel was covered by the primitive. This can lead to problems in situations such as this:

[![MSAA sample problem](https://fgiesen.files.wordpress.com/2011/07/msaa_samples.png?w=497 "MSAA sample problem")](https://fgiesen.files.wordpress.com/2011/07/msaa_samples.png)

Here, we have a pixel thatâ€™s partially covered by a primitive; the four small circles depict the 4 sampling points (this is the default 4x MSAA pattern) while the big circle in the middle depicts the pixel center. Note that the big circle is outside the primitive, and any "interpolated" value for it will actually be linear extrapolation; this is a problem if the app uses texture atlases, for example. Depending on the triangle size, the value at the pixel center can be very far off indeed. Centroid sampling solves this problem. The original explanation was that the GPU takes all of the samples covered by the primitive, computes their centroid, and samples at that position (hence the name). This is usually followed by the addition that this is just a conceptual model, and GPUs are free to do it differently, so long as the point they pick for sampling is within the primitive.

If you think it somewhat unlikely that the hardware actually counts the covered samples, sums them up, then divides by the count, then join the club. Hereâ€™s what _actually_ happens:

- If all sample points cover the primitive, interpolation is done as usual, i.e. at the pixel center (which happens to be the centroid of all sample positions for all reasonable sampling patterns).
- If not all sample points cover the triangle, the hardware picks one of the sample points that do and evaluates there. All covered sample points are (by definition) inside the primitive so this works.

That picking used to be arbitrary (i.e. left to the hardware); I believe by now DX11 actually prescribes exactly how itâ€™s done, but this more a matter of getting consistent results between different pieces of hardware than it is something that API users will actually care about. As said, itâ€™s a bit hacky. It also tends to mess up derivative calculations for quads that have partially covered pixels â€“ tough luck. What can I say, it may be industrial-strength duct tape, but itâ€™s still duct tape.

Finally (new in DX11!) thereâ€™s "pull-model" attribute interpolation. Regular attribute interpolation is done automatically before the pixel shader starts; pull-model interpolation adds actual instructions that do the interpolation to the pixel shader. This allows the shader to compute its own position to sample values at, or to only interpolate attributes in some branches but not in others. What it boils down to is the pixel shader being able to send additional requests to the interpolation unit while the shader is running.

## The Actual Shader Body

Again, the general shader principles are well-explained in the API documentation, so Iâ€™m not going to talk about how individual instructions work; generally, the answer is "as you would expect them to". There are however some interesting bits about pixel shader execution that are worth talking about.

The first one is: texture sampling! Wait, didnâ€™t I wax on about texture samplers for quite some time in part 4 already? Yes, but that was the texture sampler side of things â€“ and if you remember, there was that one bit about texture cache misses being so frequent that samplers are usually designed to sustain at least one miss to main memory per request (which is 16-32 pixels, remember!) without stalling. Thatâ€™s a lot of cycles â€“ hundreds of them. And it would be a tremendous waste of perfectly good ALUs to keep them idle while all this is going on.

So what shader units actually do is switch to a different batch after theyâ€™ve issued a texture sample; then when that batch issues a texture sample (or completes), it switches back to one of the previous batches and checks if the texture samples are there yet. As long as each shader unit has a few batches it can work on at any given time, this makes good use of available resources. It does increase latency for completion of individual batches though â€“ again, a latency-vs-throughput trade-off. By now you should know which side wins on GPUs: Throughput! _Always_. One thing to note here is that keeping multiple batches (or "Warps" on NVidia hardware, or "Wavefronts" for AMD) running at the same time requires more registers. If a shader needs a lot of registers, a shader unit can keep less warps around; and if there are less of them, the chance that at some point youâ€™ll run out of runnable batches that arenâ€™t waiting on texture results is higher. If thereâ€™s no runnable batches, youâ€™re out of luck and have to stall until one of them gets its results back. Thatâ€™s unfortunate, but thereâ€™s limited hardware resources for this kind of thing â€“ if youâ€™re out of memory, youâ€™re out of memory, period.

Another point I havenâ€™t talked about yet: Dynamic branches in shaders (i.e. loops and conditionals). In shader units, work on all elements of each batch usually proceeds in lockstep. All "threads" run the same code, at the same time. That means that ifs are a bit tricky: If _any_ of the threads want to execute the "then"-branch of an if, all of them have to â€“ even though most of them may end up ignoring the results using a technique called [predication](http://en.wikipedia.org/wiki/Branch_predication), because they didnâ€™t want to descend down there in the first place.. Similarly for the "else" branch. This works great if conditionals tend to be coherent across elements, and not so great if theyâ€™re more or less random. Worst case, youâ€™ll always execute both branches of every if. Ouch. Loops work similarly â€“ as long as at least one thread wants to keep running a loop, all of the threads in that batch/Warp/Wavefront will.

Another pixel shader specific is the `discard` instruction. A pixel shader can decide to "kill" the current pixel, which means it wonâ€™t get written. Again, if all pixels inside a batch get discarded, the shader unit can stop and go to another batch; but if thereâ€™s at least one thread left standing, the rest will be dragged along. DX11 adds more fine-grained control here by way of writing the output pixel coverage from the pixel shader (this is always ANDed with the original triangle/Z-test coverage, to make sure that a shader canâ€™t write outside its primitive, for sanity). This allows the shader to discard individual samples instead of whole pixels; it can be used to implement Alpha-to-Coverage with a custom dithering algorithm in the shader, for example.

Pixel shaders can also write the output depth (this feature has been around for quite some time now). In my experience, this is an excellent way to shoot down early-Z, hierarchical Z and Z compression and in general get the slowest path possible. By now, you know enough about how these things work to see why. ðŸ˜„

Pixel shaders produce several outputs â€“ in general, one 4-component vector for each render target, of which there can be (currently) up to 8. The shader then sends the results on down the pipeline towards what D3D calls the "Output Merger". Thisâ€™ll be our topic next time.

But before I sign off, thereâ€™s one final thing that pixel shaders can do starting with D3D11: they can write to Unordered Access Views (UAVs) â€“ something which only compute and pixel shaders can do. Generally speaking, UAVs take the place of render targets during compute shader execution; but unlike render targets, the shader can determine the position to write to itself, and thereâ€™s no implicit API order guarantee (hence the "unordered access" part of the name). For now, Iâ€™ll only mention that this functionality exists â€“ Iâ€™ll talk more about it when I get to Compute Shaders.

**Update**: In the comments, Steve gave me a heads-up about the correct AMD terminology (the first version of the post didnâ€™t have the "Wavefronts" name because I couldnâ€™t remember it) and also posted a link to [this great presentation by Kayvon Fatahalian](http://bps10.idav.ucdavis.edu/talks/03-fatahalian_gpuArchTeraflop_BPS_SIGGRAPH2010.pdf) that explains shader execution on GPUs, with a lot more pretty pictures that I can be bothered to make ðŸ˜„. You should really check it out if youâ€™re interested in how shader cores work.

Andâ€¦ thatâ€™s it! No big list of caveats this time. If thereâ€™s something missing here, itâ€™s because Iâ€™ve genuinely forgotten about it, not because I decided it was too arcane or specific to write up here. Feel free to point out omissions in the comments and Iâ€™ll see what I can do.
